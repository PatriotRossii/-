/*
Люди стоят в очереди, но никогда не уходят из её начала, зато могут приходить в конец и уходить оттуда. Также некоторые могут начинать и прекращать
**беспокоиться из-за того, что очередь не продвигается.
Реализуйте обработку следующих операций над очередью:

WORRY i: пометить i-го человека с начала очереди (в нумерации с 0) как беспокоящегося;
QUIET i: пометить i-го человека (в нумерации с 0) как успокоившегося;
COME k: добавить k спокойных человек в конец очереди;
COME -k: убрать k человек из конца очереди;
WORRY_COUNT: узнать количество беспокоящихся людей в очереди.

Изначально очередь пуста.
Реализовать операции WORRY, QUIET и COME позволят простые действия с вектором. Для реализации WORRY_COUNT понадобится честный подсчёт указанного числа.

Формат ввода

На вход программе подаётся количество операций Q, затем описания операций.
Для каждой операции WORRY i и QUIET i гарантируется, что человек с номером i существует в очереди на момент операции.
Для каждой операции COME -k гарантируется, что k не больше текущего размера очереди.
Все указанные гарантии действительно справедливы для всех запросов. Проверять их не нужно, просто пишите программу, считая, что входные данные корректны.

Формат вывода

Для каждой операции WORRY_COUNT выведите одно целое число — количество беспокоящихся людей в очереди.
*/

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int q;
    cin >> q;

    vector<int> queue;

    for(int i = 0; i < q; ++i) {
        string operation_code;
        cin >> operation_code;

        if (operation_code == "WORRY" or operation_code == "QUIET") {
            int i; cin >> i;
            queue[i] = (operation_code == "WORRY");
        } else if(operation_code == "COME") {
            int k; cin >> k;
            queue.resize(queue.size() + k, 0);
        } else if(operation_code == "WORRY_COUNT") {
            cout << count_if(queue.begin(), queue.end(), [](int a) { return a == 1; }) << endl;
        }
    }
}

